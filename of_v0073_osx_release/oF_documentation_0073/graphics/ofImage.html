<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>    
  <title>openFrameworks</title>
<!-- syntax highlighting for the documentation -->
<link rel="stylesheet" type="text/css" href="../css/style.css?44443" media="all" />
  </head>
  <body>
    <div id="content">
      <a href="http://openframeworks.cc" target= "_blank"><img src="../images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofImage</h1></div>
              <div id="editdocs">

              </div>
              
          </div>
          
          <div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">
              <p>
              
  <p>The ofImage and is a useful object for loading, saving and drawing images in openFrameworks. ofImage is a convenient class that let's you both get draw images to the screen and manipulate their pixel data. The ofImage allows you to load image from disk, manipulate the pixels, and create an OpenGL texture that you can display and manipulate on the graphics card. Loading a file into the ofImage allocates an ofPixels and creates the ofTexture to display the pixels.</p>
<p>ofImage uses a library called "freeImage" under the hood.</p>

              </p>
        	</div><!-- End Prose Block -->
         </div><!-- End Main Block -->
	</div>
		<div class="page-wide">
      	<div id="top_list">
             
             <!-- list of methods -->
               
 			
			<p class="top_list_header"><a href="#methods">class methods</a></p>
			
                 <ul class="functionslist">
                     
                              
                             <li> <a href="#allocate">allocate(...)</a> </li>
                         
                              
                             <li> <a href="#bAllocated">bAllocated()</a> </li>
                         
                              
                             <li> <a href="#bind">bind()</a> </li>
                         
                         
                              
                             <li> <a href="#clear">clear()</a> </li>
                         
                              
                             <li> <a href="#clone">clone(...)</a> </li>
                         
                              
                             <li> <a href="#crop">crop(...)</a> </li>
                         
                              
                             <li> <a href="#cropFrom">cropFrom(...)</a> </li>
                         
                              
                             <li> <a href="#draw">draw(...)</a> </li>
                         
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#drawSubsection">drawSubsection(...)</a> </li>
                         
                         
                         
                         
                              
                             <li> <a href="#getColor">getColor(...)</a> </li>
                         
                              
                             <li> <a href="#getHeight">getHeight()</a> </li>
                         
                              
                             <li> <a href="#getPixels">getPixels()</a> </li>
                         
                              
                             <li> <a href="#getPixelsRef">getPixelsRef()</a> </li>
                         
                              
                             <li> <a href="#getTextureReference">getTextureReference()</a> </li>
                         
                              
                             <li> <a href="#getWidth">getWidth()</a> </li>
                         
                              
                             <li> <a href="#grabScreen">grabScreen(...)</a> </li>
                         
                              
                             <li> <a href="#isAllocated">isAllocated()</a> </li>
                         
                              
                             <li> <a href="#isUsingTexture">isUsingTexture()</a> </li>
                         
                              
                             <li> <a href="#loadImage">loadImage(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#mirror">mirror(...)</a> </li>
                         
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#operator ofPixels_< PixelType > &">operator ofPixels_< PixelType > &()</a> </li>
                         
                              
                             <li> <a href="#operator=">operator=(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#reloadTexture">reloadTexture()</a> </li>
                         
                              
                             <li> <a href="#resetAnchor">resetAnchor()</a> </li>
                         
                              
                             <li> <a href="#resize">resize(...)</a> </li>
                         
                         
                              
                             <li> <a href="#rotate90">rotate90(...)</a> </li>
                         
                              
                             <li> <a href="#saveImage">saveImage(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#setAnchorPercent">setAnchorPercent(...)</a> </li>
                         
                              
                             <li> <a href="#setAnchorPoint">setAnchorPoint(...)</a> </li>
                         
                              
                             <li> <a href="#setColor">setColor(...)</a> </li>
                         
                              
                             <li> <a href="#setCompression">setCompression(...)</a> </li>
                         
                              
                             <li> <a href="#setFromPixels">setFromPixels(...)</a> </li>
                         
                         
                              
                             <li> <a href="#setImageType">setImageType(...)</a> </li>
                         
                              
                             <li> <a href="#setUseTexture">setUseTexture(...)</a> </li>
                         
                              
                             <li> <a href="#unbind">unbind()</a> </li>
                         
                              
                             <li> <a href="#update">update()</a> </li>
                         
                 </ul>
            
             
             
             <!-- list of variables -->              
                <p class="top_list_header"><a href="#variables">class variables</a></p>
                <ul class="functionslist">
                             <li> <a href="#bpp">int bpp</a> </li>
                             <li> <a href="#height">int height</a> </li>
                             <li> <a href="#type">int type</a> </li>
                             <li> <a href="#width">int width</a> </li>
                 </ul>
            
             
            
             <!-- list of functions -->              
            <p class="top_list_header"><a href="#functions">functions</a></p>
                <ul class="functionslist">
                     
                         
                              
                             <li> <a href="#ofLoadImage">ofLoadImage(...)</a> </li>
                         
                         
                         
                         
                              
                             <li> <a href="#ofSaveImage">ofSaveImage(...)</a> </li>
                         
                         
                 </ul>
            
		</div>

	</div>
		<div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">	
              
              <!-- methods detail -->
                  <h2><a name="methods"></a>ofImage methods</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="allocate">allocate(...)</a></h1>
	<h2>
  <p>void ofImage_::allocate(int w, int h, ofImageType type)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allocates space in the ofImage, both the ofPixels and the ofTexture that the ofImage contains.</p>
<pre><code class="cpp">img.allocate(640, 480, OF_IMAGE_COLOR);
int i = 0;
while ( i &lt; img.getPixelsRef().size() ) {
    img.getPixelsRef()[i] = abs(sin( float(i) / 18.f)) * 255.f; // make some op-art
    i++;
}
img.reloadTexture();
</code></pre>

<p>It allocates an image of width (w) and height (h). The type can be of three types: OF_IMAGE_GRAYSCALE, OF_IMAGE_COLOR, OF_IMAGE_COLOR_ALPHA. You don't need to call this before loading an image, but for when you want to allocate space ahead of when you are going to use the image. </p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bAllocated">bAllocated()</a></h1>
	<h2>
  <p>bool ofImage_::bAllocated()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Whether the image has been allocated either by a call to allocate or by loading pixel data into the image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bind">bind()</a></h1>
	<h2>
  <p>void ofImage_::bind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This binds the ofTexture instance that the ofImage contains so that it can be used for advaned drawing</p>
<pre><code class="cpp">void ofApp::setup() {
    img.allocate(256, 256, OF_IMAGE_COLOR);
    int i = 0;
    while ( i &lt; img.getPixelsRef().size() ) {
        img.getPixelsRef()[i] = abs(sin( float(i) / 18.f )) * 255.f;
        i++;
    }
    img.reloadTexture();

    mesh.setMode(OF_PRIMITIVE_TRIANGLE_STRIP);

    mesh.addVertex(ofVec2f(10, 10));
    mesh.addVertex(ofVec2f(410, 10));
    mesh.addVertex(ofVec2f(410, 410));
    mesh.addVertex(ofVec2f(10, 410));
    mesh.addVertex(ofVec2f(10, 10));

    mesh.addTexCoord(ofVec2f(0, 0));
    mesh.addTexCoord(ofVec2f(256, 0));
    mesh.addTexCoord(ofVec2f(256, 256));
    mesh.addTexCoord(ofVec2f(0, 256));
    mesh.addTexCoord(ofVec2f(0, 0));
}
void ofApp::draw(){

    ofBackground(255, 255, 255); // background white

    img.bind();
    mesh.draw();
    img.unbind();
}
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clear">clear()</a></h1>
	<h2>
  <p>void ofImage_::clear()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This clears the texture and pixels contained within the ofImage.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clone">clone(...)</a></h1>
	<h2>
  <p>void ofImage_::clone(const ofImage_&lt; SrcType &gt; &amp;mom)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to create an ofImage from another ofImage instance, copying all the pixels and the texture data while creating a new textureID.</p>
<pre><code class="cpp">ofImage second;
second.clone(first);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="crop">crop(...)</a></h1>
	<h2>
  <p>void ofImage_::crop(int x, int y, int w, int h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This crops the image to the w,h passed in from the x,y position.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="cropFrom">cropFrom(...)</a></h1>
	<h2>
  <p>void ofImage_::cropFrom(ofImage_&lt; PixelType &gt; &amp;otherImage, int x, int y, int w, int h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This crops another image into the image the cropFrom is being called on to the w,h passed in from the x,y position. The w,h are measured from the x,y, so passing 100, 100, 300, 300 will grab a 300x300 pixel block of data starting from 100, 100.</p>
<pre><code class="cpp">ofImage img1, img2;
img1.load(&quot;anImage.png&quot;);
img2.cropFrom(img1, 100, 100, 300, 300);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(const ofRectangle &amp;r)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the ofRectangle passed in, with any attendant scaling that may occur from fitting the ofImage into the bounds of the ofRectangle.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(const ofPoint &amp;p, float w, float h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the ofVec2f location and with the width and height, with any attendant scaling that may occur from fitting the ofImage into the width and height.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(float x, float y, float w, float h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the x,y location and with the width and height, with any attendant scaling that may occur from fitting the ofImage into the width and height.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(float x, float y, float z, float w, float h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the x,y,z location and with the width and height, with any attendant scaling that may occur from fitting the ofImage into the width and height. You should ensure that you turn on depth sorting using glEnable(GL_DEPTH) before trying to draw multiple objects into z-space.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(const ofPoint &amp;p)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the x,y location using the default height and width of the image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(float x, float y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the x,y location using the default height and width of the image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofImage_::draw(float x, float y, float z)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws the ofImage into the x,y,z location with the default height and width. You should ensure that you turn on depth sorting using glEnable(GL_DEPTH) before trying to draw multiple objects into z-space.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="drawSubsection">drawSubsection(...)</a></h1>
	<h2>
  <p>void ofImage_::drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="drawSubsection">drawSubsection(...)</a></h1>
	<h2>
  <p>void ofImage_::drawSubsection(float x, float y, float z, float w, float h, float sx, float sy)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="drawSubsection">drawSubsection(...)</a></h1>
	<h2>
  <p>void ofImage_::drawSubsection(float x, float y, float w, float h, float sx, float sy, float sw, float sh)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="drawSubsection">drawSubsection(...)</a></h1>
	<h2>
  <p>void ofImage_::drawSubsection(float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getColor">getColor(...)</a></h1>
	<h2>
  <p>ofColor_ ofImage_::getColor(int x, int y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the ofColor representing the pixels at the x and y position passed in.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getHeight">getHeight()</a></h1>
	<h2>
  <p>float ofImage_::getHeight()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns the height of the image in pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getPixels">getPixels()</a></h1>
	<h2>
  <p>PixelType * ofImage_::getPixels()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns a raw pointer to the pixel data.</p>
<p>This function will give you access to a continuous block of pixels. you can grab the data and do what you like with it. If you have a grayscale image, you will have (width<em>height) number of pixels. Color images will have (width</em>height<em>3) number of pixels (interlaced R,G,B), and coloralpha images will have (width</em>height*4) number of pixels (interlaced R,G,B,A).</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getPixelsRef">getPixelsRef()</a></h1>
	<h2>
  <p>ofPixels_ ofImage_::getPixelsRef()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns an ofPixels reference that you can use to manipulate the raw pixel data of the ofImage. Make sure you call either update() or reloadTexture() after making changes to the ofPixels.</p>
<pre><code class="cpp">int i = 0;
    while ( i &lt; img.getPixelsRef().size() ) {
        img.getPixelsRef()[i] = abs(cos( float(i) / (16 * j))) * 512.f;
        i+=3;
    }
    if(j &gt; 68.f)
        j = 32.f;
    else
        j += 0.025;

    img.reloadTexture();
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getTextureReference">getTextureReference()</a></h1>
	<h2>
  <p>ofTexture ofImage_::getTextureReference()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the texture reference that the ofImage contains. You can use this to directly manipulate the texture itself, but keep in mind that if you manipulate the texture directly, there is no simple way to copy the data from the texture back to the pixels and keep the ofImage in sync.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getWidth">getWidth()</a></h1>
	<h2>
  <p>float ofImage_::getWidth()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns the width of the image in pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="grabScreen">grabScreen(...)</a></h1>
	<h2>
  <p>void ofImage_::grabScreen(int x, int y, int w, int h)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Grabs pixels from the opengl window specified by the region (x, y, w, h) and turns them into an image. It resizes or allocates the ofImage if it's necessary.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="isAllocated">isAllocated()</a></h1>
	<h2>
  <p>bool ofImage_::isAllocated()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the image has been allocated either by a call to allocate or by loading pixel data into the image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="isUsingTexture">isUsingTexture()</a></h1>
	<h2>
  <p>bool ofImage_::isUsingTexture()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the ofImage has a texture or not. If not, nothing will be drawn to the screen if the draw() method is called.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="loadImage">loadImage(...)</a></h1>
	<h2>
  <p>bool ofImage_::loadImage(string fileName)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Loads in an image given by fileName. It will try it's best to guess the filetype based on the name. The program will look for the file relative to the data/ folder. </p>
<p>For example, to load an image "icon.gif" that is in the data folder you can call:</p>
<pre><code class="cpp">myImage.load(&quot;icon.gif&quot;);
</code></pre>

<p>you can also supply folder paths for subfolders within the data folder:</p>
<pre><code class="cpp">myImage.load(&quot;images/icon.gif&quot;);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="loadImage">loadImage(...)</a></h1>
	<h2>
  <p>bool ofImage_::loadImage(const ofBuffer &amp;buffer)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Loads an image from an ofBuffer instance created by, for instance, ofFile::readToBuffer(). This actually loads the image data into an ofPixels object and then into the texture.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="loadImage">loadImage(...)</a></h1>
	<h2>
  <p>bool ofImage_::loadImage(const ofFile &amp;file)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Loads an image from an ofFile instance created by, for instance, ofDirectory::getFiles(). This actually loads the image data into an ofPixels object and then into the texture.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="mirror">mirror(...)</a></h1>
	<h2>
  <p>void ofImage_::mirror(bool vertical, bool horizontal)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This reflects the pixels of the image across the vertical and/or horizontal axis.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator ofPixels_< PixelType > &">operator ofPixels_< PixelType > &()</a></h1>
	<h2>
  <p>ofImage_::operator ofPixels_&lt; PixelType &gt; &amp;()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator=">operator=(...)</a></h1>
	<h2>
  <p>ofImage_ ofImage_::operator=(const ofImage_&lt; PixelType &gt; &amp;mom)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to create an ofImage from another ofImage instance, copying all the pixels and the texture data while creating a new textureID.</p>
<p>Makes the current ofImage a copy of another ofImage. Same as clone(). </p>
<pre><code class="cpp">
image2.loadImage(&quot;face.jpg&quot;);
image1 = image2;
</code></pre>

<p>image1 and image2 are now identical. </p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator=">operator=(...)</a></h1>
	<h2>
  <p>ofImage_ ofImage_::operator=(const ofImage_&lt; SrcType &gt; &amp;mom)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to create an ofImage from another ofImage instance, copying all the pixels and the texture data while creating a new textureID.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator=">operator=(...)</a></h1>
	<h2>
  <p>ofImage_ ofImage_::operator=(ofPixels_&lt; PixelType &gt; &amp;pixels)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Allows you to set an image to pixels. This resizes the image to the size of the ofPixels and reallocates all the of the data within the image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="reloadTexture">reloadTexture()</a></h1>
	<h2>
  <p>void ofImage_::reloadTexture()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Loads any data from the ofPixels that the image contains into the ofTexture so that draw() calls will reflect chagnes to the pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="resetAnchor">resetAnchor()</a></h1>
	<h2>
  <p>void ofImage_::resetAnchor()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This removes any anchor positioning, meaning that the ofImage will be draw with the upper left hand corner at the point passed into draw().</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="resize">resize(...)</a></h1>
	<h2>
  <p>void ofImage_::resize(int newWidth, int newHeight)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Resizes the image to a new size (w, h); Can be used to scale up or down an image.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="rotate90">rotate90(...)</a></h1>
	<h2>
  <p>void ofImage_::rotate90(int rotation)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Rotates the image by a multiple of 90 degrees, for instance, if you pass in 2, then the image will be rotated 180 degrees.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="saveImage">saveImage(...)</a></h1>
	<h2>
  <p>void ofImage_::saveImage(string fileName, ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This saves the image to the file path in fileName with the image quality specified by compressionLevel. The different compression levels are:
OF_IMAGE_QUALITY_BEST,
OF_IMAGE_QUALITY_HIGH,
OF_IMAGE_QUALITY_MEDIUM,
OF_IMAGE_QUALITY_LOW,
OF_IMAGE_QUALITY_WORST</p>
<p>It will guess, based on the name, what filetype to save as. This file will be relative to the data folder. </p>
<p>You can use this, combined with grabSceen, in order to save an image:</p>
<pre><code class="cpp">myImage.grabScreen(0,0,500,500);
myImage.saveImage(&quot;partOfTheScreen.png&quot;);
</code></pre>

<p>You can also use dynamically generated names:</p>
<pre><code class="cpp">myImage.grabScreen(0,0,500,500);
myImage.saveImage(&quot;partOfTheScreen-&quot;+ofToString(snapCounter)+&quot;.png&quot;);
snapCounter++;
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="saveImage">saveImage(...)</a></h1>
	<h2>
  <p>void ofImage_::saveImage(ofBuffer &amp;buffer, ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This saves the image to the ofBuffer passed with the image quality specified by compressionLevel. This is useful when streaming files. The different compression levels are:
OF_IMAGE_QUALITY_BEST,
OF_IMAGE_QUALITY_HIGH,
OF_IMAGE_QUALITY_MEDIUM,
OF_IMAGE_QUALITY_LOW,
OF_IMAGE_QUALITY_WORST</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="saveImage">saveImage(...)</a></h1>
	<h2>
  <p>void ofImage_::saveImage(const ofFile &amp;file, ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This saves the image to the ofFile passed with the image quality specified by compressionLevel. This is useful when streaming files. The different compression levels are:
OF_IMAGE_QUALITY_BEST,
OF_IMAGE_QUALITY_HIGH,
OF_IMAGE_QUALITY_MEDIUM,
OF_IMAGE_QUALITY_LOW,
OF_IMAGE_QUALITY_WORST</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAnchorPercent">setAnchorPercent(...)</a></h1>
	<h2>
  <p>void ofImage_::setAnchorPercent(float xPct, float yPct)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Changes the drawing position specified by draw() from the normal top-left corner of the image to a position specified by xPct and yPct in relation to the dimensions of the image. This can be useful for aligning and centering images as well as rotating an image around its center. </p>
<p>Note: range of xPct and yPct is 0.0 to 1.0. For xPct, 1.0 represents the width of the image. For yPct, 1.0 represents the height of the image. These values are not capped. </p>
<p>For example to draw an image so that its center is at 100, 100:</p>
<pre><code class="cpp">myImage.setAnchorPercent(0.5, 0.5); 
myImage.draw(100, 100);
</code></pre>

<p>To rotate an image around its center at 100, 100:</p>
<pre><code class="cpp">ofPushMatrix();
  ofTranslate(100, 100, 0);
  ofRotate(45);
  myImage.setAnchorPercent(0.5, 0.5); 
  myImage.draw(0, 0); 
ofPopMatrix();
</code></pre>

<p>To align the right side of an image with the right edge of the window:</p>
<pre><code class="cpp">myImage.setAnchorPercent(1.0, 0.0);
myImage.draw(ofGetWidth(), 0);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAnchorPoint">setAnchorPoint(...)</a></h1>
	<h2>
  <p>void ofImage_::setAnchorPoint(float x, float y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Changes the drawing position specified by draw() from the normal top-left corner of the image to a position specified by x and y, measured in pixels. This can be useful for aligning and centering images as well as rotating an image around its center. </p>
<p>Note: see also setAnchorPercent() if you want to specify the anchor as a percentage of the image size. </p>
<p>For example to draw an image so that its center is at 100, 100:</p>
<pre><code class="cpp">myImage.setAnchorPoint(myImage.getWidth()/2, myImage.getHeight()/2); 
myImage.draw(100, 100);
</code></pre>

<p>To rotate an image around its center at 100, 100:</p>
<pre><code class="cpp">ofPushMatrix();
  ofTranslate(100, 100, 0);
  ofRotate(45);
  myImage.setAnchorPercent(myImage.getWidth()/2, myImage.getHeight()/2); 
  myImage.draw(0, 0); 
ofPopMatrix();
</code></pre>

<p>To align the right side of an image with the right edge of the window:</p>
<pre><code class="cpp">myImage.setAnchorPercent(myImage.getWidth(), 0.0);
myImage.draw(ofGetWidth(), 0);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setColor">setColor(...)</a></h1>
	<h2>
  <p>void ofImage_::setColor(int x, int y, ofColor_&lt; PixelType &gt; color)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the pixel at the x,y position passed in. The ofColor type needs to match the ofImage type, i.e. ofFloatImage requires that you use ofFloatPixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setCompression">setCompression(...)</a></h1>
	<h2>
  <p>void ofImage_::setCompression(ofTexCompression compression)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the compression level used when creating mipmaps for the ofTexture contained by the ofImage. This is quite different than the ofImageQualityType image quality parameter used in saveImage(). The different texture compression levels are:
    OF_COMPRESS_NONE,
    OF_COMPRESS_SRGB,
    OF_COMPRESS_ARB</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setFromPixels">setFromPixels(...)</a></h1>
	<h2>
  <p>void ofImage_::setFromPixels(const PixelType *pixels, int w, int h, ofImageType type, bool bOrderIsRGB=true)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set the pixels of the image from an array of values, for an ofFloatImage these need to be floats, for an ofImage these need to be unsigned chars. The w and h values are important so that the correct dimensions are set in the image. This assumes that you're setting the pixels from 0,0 or the upper left hand corner of the image.
The bOrderIsRGB flag allows you pass in pixel data that is BGR by setting bOrderIsRGB=false.</p>
<p>Copies in the pixel data from  the 'pixels' array. Specify the corresponding width and height of the image you are passing in with 'w' and 'h'. The image type can be OF_IMAGE_GRAYSCALE, OF_IMAGE_COLOR, or OF_IMAGE_COLORALPHA. </p>
<p>Note: that your array has to be at least as big as [ width * height * bytes per pixel ]. </p>
<p>If you have a grayscale image, you will have (width<em>height) number of pixels. Color images will have (width</em>height<em>3) number of pixels (interlaced R,G,B), and coloralpha images will have (width</em>height*4) number of pixels (interlaced R,G,B,A).</p>
<p>Note: You do not need to call allocate() before calling setFromPixels() as setFromPixels() re-allocates itself if needed. </p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setFromPixels">setFromPixels(...)</a></h1>
	<h2>
  <p>void ofImage_::setFromPixels(const ofPixels_&lt; PixelType &gt; &amp;pixels)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set the pixels of the image from an ofPixels instance, for an ofFloatImage these need to be ofFloatPixels, for an ofImage these need to be unsigned chars. The w and h values are important so that the correct dimensions are set in the image. This assumes that you're setting the pixels from 0,0 or the upper left hand corner of the image.
The bOrderIsRGB flag allows you pass in pixel data that is BGR by setting bOrderIsRGB=false.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setImageType">setImageType(...)</a></h1>
	<h2>
  <p>void ofImage_::setImageType(ofImageType type)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set the type of image to one of the following: OF_IMAGE_GRAYSCALE, OF_IMAGE_COLOR, OF_IMAGE_COLOR_ALPHA. This does cause the image to be reallocated and the texture to be updated, so it can be an expensive operation if done frequently. Converting down, for example from color to grayscale, loses information and is a destructive change.</p>
<p>For example, you can load in a color image, and convert it to grayscale:</p>
<pre><code class="cpp">myImage.loadImage(&quot;somethingColor.jpg&quot;);
myImage.setImageType(OF_IMAGE_GRAYSCALE);   // now I am grayscale;
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUseTexture">setUseTexture(...)</a></h1>
	<h2>
  <p>void ofImage_::setUseTexture(bool bUse)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If you set the ofImage to not use a texture it will contain the pixels of the image but cannot be drawn to the screen without copying its data into an ofTexture instance.</p>
<p>This turns on or off the allocation and use of a texture. any time you change the image (loading, resizing, converting the type), ofImage will uplaod data to an opengl texture. It may not be necessary, though, and it could be that you need to save memory on the graphics card, or that you don't need to draw this image on the screen. You can call this even before you load an image in to OF:</p>
<pre><code class="cpp">myImage.setUseTexture(false);
myImage.loadImage(&quot;blah.gif&quot;);
</code></pre>

<p>Since in the majority of cases, ofImages will be loaded in and drawn onscreen, the default is set to use a texture.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="unbind">unbind()</a></h1>
	<h2>
  <p>void ofImage_::unbind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This unbinds the ofTexture instance that the ofImage contains. Call this after you call bind().</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="update">update()</a></h1>
	<h2>
  <p>void ofImage_::update()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This method should be called after you update the pixels of the image and want to ensure that the changes to the pixels are reflected in the ofTexture of the image. Many of the ofImage methods call this after they change the pixels, but if you directly manipulate the pixels of the ofImage, then you should make sure to call update() before trying to draw the texture of the image to the screen.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- vars detail -->
                  <h2><a name="variables"></a>ofImage variables</h2>
                            
<div class="documentation_detail">
	<h1>int <a name="bpp">bpp</a></h1>
	<h2>
  <p>int ofImage_::bpp</p>
</h2>
	<div class="documentation_detail_description">
		
  <p>Bytes per pixels of the image. This will be 3 for OF_IMAGE_COLOR with unsigned char pixels and 12 for an OF_COLOR_IMAGE with float pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
	<h1>int <a name="height">height</a></h1>
	<h2>
  <p>int ofImage_::height</p>
</h2>
	<div class="documentation_detail_description">
		
  <p>Height of the image in pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
	<h1>int <a name="type">type</a></h1>
	<h2>
  <p>int ofImage_::type</p>
</h2>
	<div class="documentation_detail_description">
		
  <p>Returns the type of image, OF_IMAGE_COLOR, OF_IMAGE_COLOR_ALPHA, or OF_IMAGE_GRAYSCALE</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
	<h1>int <a name="width">width</a></h1>
	<h2>
  <p>int ofImage_::width</p>
</h2>
	<div class="documentation_detail_description">
		
  <p>Width of the image in pixels.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- functions detail -->
                  <h2><a name="functions"></a>ofImage functions</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofLoadImage">ofLoadImage(...)</a></h1>
	<h2>
  <p>bool ofLoadImage(ofPixels &amp;pix, string path)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofLoadImage">ofLoadImage(...)</a></h1>
	<h2>
  <p>bool ofLoadImage(ofPixels &amp;pix, const ofBuffer &amp;buffer)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofLoadImage">ofLoadImage(...)</a></h1>
	<h2>
  <p>bool ofLoadImage(ofTexture &amp;tex, string path)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofLoadImage">ofLoadImage(...)</a></h1>
	<h2>
  <p>bool ofLoadImage(ofTexture &amp;tex, const ofBuffer &amp;buffer)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofSaveImage">ofSaveImage(...)</a></h1>
	<h2>
  <p>void ofSaveImage(ofPixels &amp;pix, string path, ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="ofSaveImage">ofSaveImage(...)</a></h1>
	<h2>
  <p>void ofSaveImage(ofPixels &amp;pix, ofBuffer &amp;buffer, ofImageFormat format=OF_IMAGE_FORMAT_PNG, ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
            </div><!-- End Prose Block -->
          </div><!-- End Main Block -->
        </div>
      </div>
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Thursday, 17 January 2013 05:14:27 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

bb9a3174291cb0971a5d51babc9f9bc360090b5e
">

bb9a3174291cb0971a5d51babc9f9bc360090b5e
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





<script language="javascript"><!--
bmi_SafeAddOnload(bmi_load,"bmi_orig_img",0);//-->
</script>