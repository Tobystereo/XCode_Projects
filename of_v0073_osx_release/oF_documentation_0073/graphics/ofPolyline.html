<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>    
  <title>openFrameworks</title>
<!-- syntax highlighting for the documentation -->
<link rel="stylesheet" type="text/css" href="../css/style.css?44443" media="all" />
  </head>
  <body>
    <div id="content">
      <a href="http://openframeworks.cc" target= "_blank"><img src="../images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofPolyline</h1></div>
              <div id="editdocs">

              </div>
              
          </div>
          
          <div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">
              <p>
              
  <p>ofPolyLine allows you to combine multiple points into a single vector data object that can be drawn to the screen, manipulated point by point, and combined with other ofPolyline instances. It is less complex than the <a href="ofPath.html">ofPath</a> and generally represents a single line or vector shape rather than multiple lines or shapes.</p>
<p>You can add points to an ofPolyline by adding vertices:</p>
<pre><code class="cpp">float i = 0;
while (i &lt; TWO_PI) { // make a heart
    float r = (2-2*sin(i) + sin(i)*sqrt(abs(cos(i))) / (sin(i)+1.4)) * -80;
    float x = ofGetWidth()/2 + cos(i) * r;
    float y = ofGetHeight()/2 + sin(i) * r;
    line.addVertex(ofVec2f(x,y));
    i+=0.005*HALF_PI*0.5;
}
line.close(); // close the shape
</code></pre>

<p>or you can draw lines or curves:</p>
<pre><code class="cpp">float angle = 0;
while (angle &lt; TWO_PI ) {
    b.curveTo(100*cos(angle), 0, 100*sin(angle));
    b.curveTo(300*cos(angle), 300, 300*sin(angle));
    angle += TWO_PI / 30;
}
</code></pre>

<p>ofPolyline also includes methods to get the cloeset point, determien whether a point is inside shape, and resample shapes. Along with the ofPath class, it's the best way to draw and manipulate 2D and 3D vector graphics that you'll need to update and manipulate frequently.
If you use the line or curveTo or bezierTo functions, you move the drawing point, so that drawing a line to 100,100 means a line from 0,0 to 100, 100. The next line would be a line from 100,100 to whereever you go next. Storing this position means that you can easily create continuous drawings without difficulty.</p>

              </p>
        	</div><!-- End Prose Block -->
         </div><!-- End Main Block -->
	</div>
		<div class="page-wide">
      	<div id="top_list">
             
             <!-- list of methods -->
               
 			
			<p class="top_list_header"><a href="#methods">class methods</a></p>
			
                 <ul class="functionslist">
                     
                              
                             <li> <a href="#addVertex">addVertex(...)</a> </li>
                         
                         
                              
                             <li> <a href="#addVertexes">addVertexes(...)</a> </li>
                         
                         
                              
                             <li> <a href="#addVertices">addVertices(...)</a> </li>
                         
                         
                              
                             <li> <a href="#arc">arc(...)</a> </li>
                         
                         
                         
                         
                              
                             <li> <a href="#arcNegative">arcNegative(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#bezierTo">bezierTo(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#clear">clear()</a> </li>
                         
                              
                             <li> <a href="#close">close()</a> </li>
                         
                              
                             <li> <a href="#curveTo">curveTo(...)</a> </li>
                         
                         
                              
                             <li> <a href="#draw">draw()</a> </li>
                         
                              
                             <li> <a href="#fromRectangle">fromRectangle(...)</a> </li>
                         
                              
                             <li> <a href="#getArea">getArea()</a> </li>
                         
                              
                             <li> <a href="#getBoundingBox">getBoundingBox()</a> </li>
                         
                              
                             <li> <a href="#getCentroid2D">getCentroid2D()</a> </li>
                         
                              
                             <li> <a href="#getClosestPoint">getClosestPoint(...)</a> </li>
                         
                              
                             <li> <a href="#getPerimeter">getPerimeter()</a> </li>
                         
                              
                             <li> <a href="#getResampledByCount">getResampledByCount(...)</a> </li>
                         
                              
                             <li> <a href="#getResampledBySpacing">getResampledBySpacing(...)</a> </li>
                         
                              
                             <li> <a href="#getSmoothed">getSmoothed(...)</a> </li>
                         
                              
                             <li> <a href="#getVertices">getVertices()</a> </li>
                         
                              
                             <li> <a href="#hasChanged">hasChanged()</a> </li>
                         
                              
                             <li> <a href="#inside">inside(...)</a> </li>
                         
                         
                         
                         
                              
                             <li> <a href="#isClosed">isClosed()</a> </li>
                         
                              
                             <li> <a href="#lineTo">lineTo(...)</a> </li>
                         
                         
                              
                             <li> <a href="#operator[]">operator[](...)</a> </li>
                         
                              
                             <li> <a href="#quadBezierTo">quadBezierTo(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#resize">resize(...)</a> </li>
                         
                         
                              
                             <li> <a href="#setClosed">setClosed(...)</a> </li>
                         
                              
                             <li> <a href="#simplify">simplify(...)</a> </li>
                         
                              
                             <li> <a href="#size">size()</a> </li>
                         
                         
                 </ul>
            
             
             
             <!-- list of variables -->              
            
             
            
             <!-- list of functions -->              
            
		</div>

	</div>
		<div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">	
              
              <!-- methods detail -->
                  <h2><a name="methods"></a>ofPolyline methods</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertex">addVertex(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertex(const ofPoint &amp;p)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Adds a point using an ofPoint at the end of the ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertex">addVertex(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertex(float x, float y, float z=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Adds a point using floats instead of an ofPoint at the end of the ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertexes">addVertexes(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertexes(const vector&lt; ofPoint &gt; &amp;verts)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Adds multiple points at the end of the ofPolyline using a vector of ofPoint objects, which can be declared like so:</p>
<pre><code class="cpp">vector&lt;ofPoint&gt; verts;
// make a pentagon
float size = 80.f;
float X1 = 0.125*sqrt(10 + 2*sqrt(5)) * size;
float X2 = 0.125*sqrt(10 - 2*sqrt(5)) * size;
float Y1 = 0.125*(sqrt(5) - 1) * size;
float Y2 = 0.125*(sqrt(5) + 1) * size;
verts.push_back(ofPoint(0, -0.5 * size));
verts.push_back(ofPoint(-X1, -Y1));
verts.push_back(ofPoint(-X2, Y2));
verts.push_back(ofPoint(X2, Y2));
verts.push_back(ofPoint(X1, -Y1));
ofPolyline p;
p.addVertexes(verts);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertexes">addVertexes(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertexes(const ofPoint *verts, int numverts)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Adds multiple points at the end of the ofPolyline using a pointer to an array of ofPoint objects.</p>
<pre><code class="cpp">ofPoint* verts = new ofPoint[5];
// make a pentagon
float size = 80.f;
float X1 = 0.125*sqrt(10 + 2*sqrt(5)) * size;
float X2 = 0.125*sqrt(10 - 2*sqrt(5)) * size;
float Y1 = 0.125*(sqrt(5) - 1) * size;
float Y2 = 0.125*(sqrt(5) + 1) * size;
verts[0] = ofPoint(0, -0.5 * size);
verts[1] = ofPoint(-X1, -Y1);
verts[2] = ofPoint(-X2, Y2);
verts[3] = ofPoint(X2, Y2);
verts[4] = ofPoint(X1, -Y1);
ofPolyline p;
p.addVertexes(verts, 5);
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertices">addVertices(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertices(const vector&lt; ofPoint &gt; &amp;verts)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="addVertices">addVertices(...)</a></h1>
	<h2>
  <p>void ofPolyline::addVertices(const ofPoint *verts, int numverts)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arc">arc(...)</a></h1>
	<h2>
  <p>void ofPolyline::arc(const ofPoint &amp;center, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draw an arc around the ofPoint p with the width of radiusX and the height of radiusY. The angleBegin and angleEnd indicate how far around you want the arc to extend. For instance, to draw a circle:</p>
<pre><code class="cpp">ofPoint p(0, 0);
polyline.arc(p,100,100,0,360,40); // circle with a diameter of 100
</code></pre>

<pre><code class="cpp">ofPoint p(100, 0);
polyline.arc(p,100,100,0,180,40); // semi-circle with a diameter of 100
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arc">arc(...)</a></h1>
	<h2>
  <p>void ofPolyline::arc(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draw an arc around the point x,y with the width of radiusX and the height of radiusY. The angleBegin and angleEnd indicate how far around you want the arc to extend. For instance, to draw a circle:</p>
<pre><code class="cpp">polyline.arc(0,0,100,100,0,360,40); // circle with a diameter of 100
</code></pre>

<pre><code class="cpp">polyline.arc(0,0,100,100,0,180,40); // semi-circle with a diameter of 100
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arc">arc(...)</a></h1>
	<h2>
  <p>void ofPolyline::arc(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draw an arc around the point x,y,z with the width of radiusX and the height of radiusY. The angleBegin and angleEnd indicate how far around you want the arc to extend. For instance, to draw a circle:</p>
<pre><code class="cpp">// at middle and -100 back
polyline.arc(ofGetWidth()/2,ofGetHeight()/2,100,100,100,0,360,40); // circle with a diameter of 100
</code></pre>

<pre><code class="cpp">// at middle and -100 back
polyline.arc(ofGetWidth()/2,ofGetHeight()/2,100,100,100,0,180,40); // semi-circle with a diameter of 100
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arc">arc(...)</a></h1>
	<h2>
  <p>void ofPolyline::arc(const ofPoint &amp;center, float radiusX, float radiusY, float angleBegin, float angleEnd, bool clockwise, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arcNegative">arcNegative(...)</a></h1>
	<h2>
  <p>void ofPolyline::arcNegative(const ofPoint &amp;center, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arcNegative">arcNegative(...)</a></h1>
	<h2>
  <p>void ofPolyline::arcNegative(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="arcNegative">arcNegative(...)</a></h1>
	<h2>
  <p>void ofPolyline::arcNegative(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd, int curveResolution=20)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bezierTo">bezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::bezierTo(const ofPoint &amp;cp1, const ofPoint &amp;cp2, const ofPoint &amp;to, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a cubic bezier line from the current drawing point with the 2 control points indicated by ofPoint cp1 and cp2, that ends at ofPoint to. For instance, the following:</p>
<pre><code class="cpp">line.addVertex(ofPoint(200, 400));
line.bezierTo(100, 100, 800, 100, 700, 400);
</code></pre>

<p>Creates this:
<img alt="polyline bezier" src="bezier.png" />
The control points are shown in yellow.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bezierTo">bezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::bezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a cubic bezier line from the current drawing point with the 2 control points indicated by the coordinates cx1, cy1 and cx2, cy2, that ends at the coordinates x, y.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bezierTo">bezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::bezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a cubic bezier line in 3D space from the current drawing point with the 2 control points indicated by the coordinates cx1, cy1, cz1 and cx2, cy2, cz2, that ends at the coordinates x, y, z.</p>
<pre><code class="cpp">float cx = ofGetWidth()/2;
float cy = 200;
float step = TWO_PI / 60;
for (float i = 0.0; i &lt; TWO_PI; i+=step) {

    if(i == 0.0) {
        line.addVertex(cx + (400*cos(i)), cy+400, 400 * sin(i));
    } else {
        line.bezierTo( cx - (200*cos(i)), cy-100, 400 * sin(i), 
                       cx + (200*cos(i)), cy+600, 400 * sin(i), 
                       cx + (400*cos(i)), cy+400, 400 * sin(i));
    }
}
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clear">clear()</a></h1>
	<h2>
  <p>void ofPolyline::clear()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Removes all the points from the ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="close">close()</a></h1>
	<h2>
  <p>void ofPolyline::close()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Closes the ofPolyline, meaning that all the vertices will be linked and can be "walked".</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="curveTo">curveTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::curveTo(const ofPoint &amp;to, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws a curve to an ofPoint object passed in:</p>
<pre><code class="cpp">float angle = 0;
while (angle &lt; TWO_PI ) {
    b.curveTo( ofPoint(100*cos(angle), 100*sin(angle)));
    b.curveTo( ofPoint(300*cos(angle), 300*sin(angle)));
    angle += TWO_PI / 30;
}
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="curveTo">curveTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::curveTo(float x, float y, float z=0, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draws a curve to the x,y,z points passed in with the optional resolution.</p>
<pre><code class="cpp">float angle = 0;
while (angle &lt; TWO_PI ) {
    polyline.curveTo(100*cos(angle), 0, 100*sin(angle));
    polyline.curveTo(300*cos(angle), 300, 300*sin(angle));
    angle += TWO_PI / 30;
}
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw()</a></h1>
	<h2>
  <p>void ofPolyline::draw()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Draw the line using the current renderer.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="fromRectangle">fromRectangle(...)</a></h1>
	<h2>
  <p>ofPolyline ofPolyline::fromRectangle(const ofRectangle &amp;rect)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getArea">getArea()</a></h1>
	<h2>
  <p>float ofPolyline::getArea()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Gets the precise area bounded by the line.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getBoundingBox">getBoundingBox()</a></h1>
	<h2>
  <p>ofRectangle ofPolyline::getBoundingBox()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns the bounding box of the shape, taking into account all the points to determine the extents of the polyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getCentroid2D">getCentroid2D()</a></h1>
	<h2>
  <p>ofPoint ofPolyline::getCentroid2D()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Get the center of the area bounded by the line.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getClosestPoint">getClosestPoint(...)</a></h1>
	<h2>
  <p>ofPoint ofPolyline::getClosestPoint(const ofPoint &amp;target, unsigned int *nearestIndex=NULL)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the point on the line closest to the target. You can also optionally pass a pointer to/address of an unsigned int to get the index of the closest vertex.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getPerimeter">getPerimeter()</a></h1>
	<h2>
  <p>float ofPolyline::getPerimeter()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns the size of the perimeter of the polyline, good for determining length of the line, rather than just the bounding box shape.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getResampledByCount">getResampledByCount(...)</a></h1>
	<h2>
  <p>ofPolyline ofPolyline::getResampledByCount(int count)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This resamples the line based on the spacing passed in. The lower the count passed in, the more points will be eliminated. This doesn't add new points to the line though.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getResampledBySpacing">getResampledBySpacing(...)</a></h1>
	<h2>
  <p>ofPolyline ofPolyline::getResampledBySpacing(float spacing)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This resamples the line based on the spacing passed in. The larger the spacing, the more points will be eliminated.</p>
<pre><code class="cpp">line.draw();
ofTranslate(400, 0);
line.getResampledBySpacing(100).draw();
</code></pre>

<p><img alt="polyline resample" src="resample.png" /></p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getSmoothed">getSmoothed(...)</a></h1>
	<h2>
  <p>ofPolyline ofPolyline::getSmoothed(int smoothingSize, float smoothingShape=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns a smoothed version of the ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getVertices">getVertices()</a></h1>
	<h2>
  <p>ofPoint ofPolyline::getVertices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns the vector of vertices that the line contains, vector<ofPoint> &amp;.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="hasChanged">hasChanged()</a></h1>
	<h2>
  <p>bool ofPolyline::hasChanged()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the vertices within the line have changed.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="inside">inside(...)</a></h1>
	<h2>
  <p>bool ofPolyline::inside(float x, float y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Tests whether the x,y coordinates are within a closed ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="inside">inside(...)</a></h1>
	<h2>
  <p>bool ofPolyline::inside(const ofPoint &amp;p)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Tests whether the ofPoint is within a closed ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="inside">inside(...)</a></h1>
	<h2>
  <p>bool ofPolyline::inside(float x, float y, const ofPolyline &amp;polyline)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Test whether the x,y point is within anothe polyline, passed in as ofPolyline&amp;</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="inside">inside(...)</a></h1>
	<h2>
  <p>bool ofPolyline::inside(const ofPoint &amp;p, const ofPolyline &amp;polyline)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Test whether the ofPoint is within anothe polyline, passed in as ofPolyline&amp;</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="isClosed">isClosed()</a></h1>
	<h2>
  <p>bool ofPolyline::isClosed()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Whether the shape is closed or not. Certain operations, like getSmoothed() can only be performed on closed shapes.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="lineTo">lineTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::lineTo(const ofPoint &amp;to)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Add a line from the last point added, or from 0,0 if no point is set, to the point indicated by the ofPoint passesd in.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="lineTo">lineTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::lineTo(float x, float y, float z=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Add a line from the last point added, or from 0,0 if no point is set, to the point indicated by the floats x,y,z passesd in.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator[]">operator[](...)</a></h1>
	<h2>
  <p>ofPoint ofPolyline::operator<a href="int index"></a></p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>The [] operator allows you to access the points of the ofPolyline just like you would in an array, so to make the points of a line follow the mouse movement, you could do:</p>
<pre><code class="cpp">line[0].set(mouseX, mouseY);
int i = 1;
while ( i&lt;bounds.size()) {

    float angle = atan2(line[i-1].y - line[i].y, line[i-1].x - line[i].x);  
    bounds[i].set(bounds[i-1].x - cos(angle) * 20, bounds[i-1].y - sin(angle) * 20);

    i++;
}
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="quadBezierTo">quadBezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::quadBezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a quadratic bezier line in 3D space from the current drawing point with the beginning indicated by the coordinates cx1, cy1, cz1, the control point at cx2, cy2, cz2, and that ends at the coordinates x, y, z.
<img alt="polyline curves" src="curves.png" /></p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="quadBezierTo">quadBezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::quadBezierTo(const ofPoint &amp;p1, const ofPoint &amp;p2, const ofPoint &amp;p3, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a quadratic bezier line in 2D space from the current drawing point with the beginning indicated by the point p1, the control point at p2, and that ends at the point p3.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="quadBezierTo">quadBezierTo(...)</a></h1>
	<h2>
  <p>void ofPolyline::quadBezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y, int curveResolution=16)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Creates a quadratic bezier line in 3D space from the current drawing point with the beginning indicated by the coordinates cx1, cy1, the control point at cx2, cy2, and that ends at the coordinates x, y.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="resize">resize(...)</a></h1>
	<h2>
  <p>void ofPolyline::resize(size_t size)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Resize the number of points in the ofPolyline to the value passed in.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setClosed">setClosed(...)</a></h1>
	<h2>
  <p>void ofPolyline::setClosed(bool tf)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Closes the ofPolyline, meaning that all the vertices will be linked and can be "walked".</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="simplify">simplify(...)</a></h1>
	<h2>
  <p>void ofPolyline::simplify(float tolerance=0.3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Simplifies the polyline, removing un-necessary vertices. The tolerance determines how dis-similar points need to be to stay in the line. Higher tolerance means more points removed, lower tolerance means less points removed.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="size">size()</a></h1>
	<h2>
  <p>size_t ofPolyline::size()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>The number of points in the ofPolyline.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- vars detail -->
              
              <!-- functions detail -->
            </div><!-- End Prose Block -->
          </div><!-- End Main Block -->
        </div>
      </div>
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Thursday, 17 January 2013 05:14:27 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

bb9a3174291cb0971a5d51babc9f9bc360090b5e
">

bb9a3174291cb0971a5d51babc9f9bc360090b5e
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





<script language="javascript"><!--
bmi_SafeAddOnload(bmi_load,"bmi_orig_img",0);//-->
</script>