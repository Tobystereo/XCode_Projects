<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>    
  <title>openFrameworks</title>
<!-- syntax highlighting for the documentation -->
<link rel="stylesheet" type="text/css" href="../css/style.css?44443" media="all" />
  </head>
  <body>
    <div id="content">
      <a href="http://openframeworks.cc" target= "_blank"><img src="../images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofShader</h1></div>
              <div id="editdocs">

              </div>
              
          </div>
          
          <div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">
              <p>
              
  <p>Graphics Language Shading Language (GLSL) can be used in oF by using the ofShader object. Shading happens in two distinct steps: the vertex shader creates values for each vertex in the model, and the fragment shader creates values for each pixel in the rendered object. To define a shader, create a .frag file for the fragment shader and a .vert file for the vertex shader.
A vertex shader has attributes about a location in space or vertex, which means not only the actual coordinates of that location but also its color, how any textures should be mapped onto it, and how the vertices are modified in the operation. A vertex shader can change the positions of each vertex, the number of lighting computations per vertex, and the color that will be applied to each vertex.
A geometry shader can generate new graphics primitives like points, lines, and triangles, from those primitives that were sent to the graphics card from the CPU. This means that you could get a point and turn it into a triangle or even a bunch of triangles, or get a line and turn it into a rectangle, or do real-time extrusion. They are very powerful and can be quite tricky to get right, but theyre becoming more popular.
The fragment shader is somewhat misleadingly named because what it really allows you to do is to change values assigned to each pixel. The vertex shader operates on the vertices, and the fragment shader operates on the pixels. By the time the fragment shader gets information passed into it by the graphics card, the color of a particular pixel has already been computed and in the fragment shader can be combined with an element like a lighting effecting, a fog effect, or a blur among many other options. The usual end result of this stage per fragment is a color value and a depth for the fragment.</p>

              </p>
        	</div><!-- End Prose Block -->
         </div><!-- End Main Block -->
	</div>
		<div class="page-wide">
      	<div id="top_list">
             
             <!-- list of methods -->
               
 			
			<p class="top_list_header"><a href="#methods">class methods</a></p>
			
                 <ul class="functionslist">
                     
                              
                             <li> <a href="#begin">begin()</a> </li>
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#end">end()</a> </li>
                         
                         
                         
                              
                             <li> <a href="#getGeometryMaxOutputCount">getGeometryMaxOutputCount()</a> </li>
                         
                              
                             <li> <a href="#getProgram">getProgram()</a> </li>
                         
                              
                             <li> <a href="#getShader">getShader(...)</a> </li>
                         
                         
                              
                             <li> <a href="#linkProgram">linkProgram()</a> </li>
                         
                              
                             <li> <a href="#load">load(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#printActiveAttributes">printActiveAttributes()</a> </li>
                         
                              
                             <li> <a href="#printActiveUniforms">printActiveUniforms()</a> </li>
                         
                              
                             <li> <a href="#setAttribute1d">setAttribute1d(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute1f">setAttribute1f(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute1s">setAttribute1s(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute2d">setAttribute2d(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute2f">setAttribute2f(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute2s">setAttribute2s(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute3d">setAttribute3d(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute3f">setAttribute3f(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute3s">setAttribute3s(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute4d">setAttribute4d(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute4f">setAttribute4f(...)</a> </li>
                         
                              
                             <li> <a href="#setAttribute4s">setAttribute4s(...)</a> </li>
                         
                              
                             <li> <a href="#setGeometryInputType">setGeometryInputType(...)</a> </li>
                         
                              
                             <li> <a href="#setGeometryOutputCount">setGeometryOutputCount(...)</a> </li>
                         
                              
                             <li> <a href="#setGeometryOutputType">setGeometryOutputType(...)</a> </li>
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#setUniformMatrix4f">setUniformMatrix4f(...)</a> </li>
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#setupShaderFromFile">setupShaderFromFile(...)</a> </li>
                         
                              
                             <li> <a href="#setupShaderFromSource">setupShaderFromSource(...)</a> </li>
                         
                              
                             <li> <a href="#unload">unload()</a> </li>
                         
                 </ul>
            
             
             
             <!-- list of variables -->              
            
             
            
             <!-- list of functions -->              
            
		</div>

	</div>
		<div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">	
              
              <!-- methods detail -->
                  <h2><a name="methods"></a>ofShader methods</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="begin">begin()</a></h1>
	<h2>
  <p>void ofShader::begin()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>After you call begin() everything that you draw, vertexes and textures, in your of application have the effects of the shader applied to them.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="end">end()</a></h1>
	<h2>
  <p>void ofShader::end()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>After you call end() any drawing, vertexes and textures, do not have the effect of the shader applied to them.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getAttributeLocation">getAttributeLocation(...)</a></h1>
	<h2>
  <p>GLint ofShader::getAttributeLocation(const char *name)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getGeometryMaxOutputCount">getGeometryMaxOutputCount()</a></h1>
	<h2>
  <p>int ofShader::getGeometryMaxOutputCount()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>returns maximum number of supported vertices for your graphics card</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getProgram">getProgram()</a></h1>
	<h2>
  <p>GLuint &amp; ofShader::getProgram()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This is all the shaders: vertex, geom, and frag.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getShader">getShader(...)</a></h1>
	<h2>
  <p>GLuint &amp; ofShader::getShader(GLenum type)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This returns only one of the shaders. You can pass GL_VERTEX_SHADER, GL_GEOMETRY_SHADER_EXT, GL_FRAGMENT_SHADER</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="linkProgram">linkProgram()</a></h1>
	<h2>
  <p>bool ofShader::linkProgram()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Links program with all compiled shaders. This is more of an advanced use method, as this is done automatically for you.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="load">load(...)</a></h1>
	<h2>
  <p>bool ofShader::load(string shaderName)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This assumes that your vertex and fragment shaders have the same name, i.e. "dof.vert" and "dof.frag" and loads them using just the name of the shader:</p>
<pre><code class="cpp">shader.load(&quot;dof&quot;); // assumes the shaders are in /data
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="load">load(...)</a></h1>
	<h2>
  <p>bool ofShader::load(string vertName, string fragName, string geomName="")</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Here you can load shaders with whatever names you choose. The geometry shader is optional, but the vertex and fragment shaders aren't.</p>
<pre><code class="cpp">shader.load(&quot;dof.vert&quot;, &quot;dof.frag&quot;); // assumes the shaders are in /data
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="printActiveAttributes">printActiveAttributes()</a></h1>
	<h2>
  <p>void ofShader::printActiveAttributes()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This prints out all the active attributes to the console.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="printActiveUniforms">printActiveUniforms()</a></h1>
	<h2>
  <p>void ofShader::printActiveUniforms()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This prints out all the active uniforms to the console.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute1d">setAttribute1d(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute1d(GLint location, double v1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set one double attribute on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute1f">setAttribute1f(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute1f(GLint location, float v1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set one float attributes on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute1s">setAttribute1s(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute1s(GLint location, short v1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set a short attribute, a short int, on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute2d">setAttribute2d(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute2d(GLint location, double v1, double v2)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set two double attribute on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute2f">setAttribute2f(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute2f(GLint location, float v1, float v2)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set two float attributes on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute2s">setAttribute2s(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute2s(GLint location, short v1, short v2)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set two short attributes, a short int, on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute3d">setAttribute3d(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute3d(GLint location, double v1, double v2, double v3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set three double attribute on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute3f">setAttribute3f(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute3f(GLint location, float v1, float v2, float v3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set three float attributes on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute3s">setAttribute3s(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute3s(GLint location, short v1, short v2, short v3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set three short attributes, a short int, on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute4d">setAttribute4d(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute4d(GLint location, double v1, double v2, double v3, double v4)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set four double attribute on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute4f">setAttribute4f(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute4f(GLint location, float v1, float v2, float v3, float v4)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set four float attributes on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAttribute4s">setAttribute4s(...)</a></h1>
	<h2>
  <p>void ofShader::setAttribute4s(GLint location, short v1, short v2, short v3, short v4)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Set four short attributes, a short int, on the shader.
Attributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setGeometryInputType">setGeometryInputType(...)</a></h1>
	<h2>
  <p>void ofShader::setGeometryInputType(GLenum type)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>You have to call this before linking the program with geometry shaders.
Possible types are GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_EXT, GL_TRIANGLES, GL_TRIANGLES_ADJACENCY_EXT</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setGeometryOutputCount">setGeometryOutputCount(...)</a></h1>
	<h2>
  <p>void ofShader::setGeometryOutputCount(int count)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>You have to call this before linking the program with geometry shaders to set the number of output vertices, For quads, this should be 4, for points 1. Triangle strips can use up to the maximum number. You can check the maximum number supported on your graphics cards with getGeometryMaxOutputCount()</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setGeometryOutputType">setGeometryOutputType(...)</a></h1>
	<h2>
  <p>void ofShader::setGeometryOutputType(GLenum type)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>You have to call this before linking the program with geometry shaders.
type: GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform1f">setUniform1f(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform1f(const char *name, float v1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform1fv">setUniform1fv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform1fv(const char <em>name, float </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform1i">setUniform1i(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform1i(const char *name, int v1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform1iv">setUniform1iv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform1iv(const char <em>name, int </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform2f">setUniform2f(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform2f(const char *name, float v1, float v2)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform2fv">setUniform2fv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform2fv(const char <em>name, float </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform2i">setUniform2i(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform2i(const char *name, int v1, int v2)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform2iv">setUniform2iv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform2iv(const char <em>name, int </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform3f">setUniform3f(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform3f(const char *name, float v1, float v2, float v3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform3fv">setUniform3fv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform3fv(const char <em>name, float </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform3i">setUniform3i(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform3i(const char *name, int v1, int v2, int v3)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform3iv">setUniform3iv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform3iv(const char <em>name, int </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform4f">setUniform4f(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform4f(const char *name, float v1, float v2, float v3, float v4)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform4fv">setUniform4fv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform4fv(const char <em>name, float </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform4i">setUniform4i(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform4i(const char *name, int v1, int v2, int v3, int v4)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniform4iv">setUniform4iv(...)</a></h1>
	<h2>
  <p>void ofShader::setUniform4iv(const char <em>name, int </em>v, int count=1)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniformMatrix4f">setUniformMatrix4f(...)</a></h1>
	<h2>
  <p>void ofShader::setUniformMatrix4f(const char *name, const ofMatrix4x4 &amp;m)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniformTexture">setUniformTexture(...)</a></h1>
	<h2>
  <p>void ofShader::setUniformTexture(const char *name, ofBaseHasTexture &amp;img, int textureLocation)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniformTexture">setUniformTexture(...)</a></h1>
	<h2>
  <p>void ofShader::setUniformTexture(const char *name, ofTexture &amp;img, int textureLocation)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUniformTexture">setUniformTexture(...)</a></h1>
	<h2>
  <p>void ofShader::setUniformTexture(const char *name, int textureTarget, GLint textureID, int textureLocation)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setupShaderFromFile">setupShaderFromFile(...)</a></h1>
	<h2>
  <p>bool ofShader::setupShaderFromFile(GLenum type, string filename)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This are more of advanced use function and doesn't need.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setupShaderFromSource">setupShaderFromSource(...)</a></h1>
	<h2>
  <p>bool ofShader::setupShaderFromSource(GLenum type, string source)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>these methods create and compile a shader from a string, type: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_GEOMETRY_SHADER_EXT etc.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="unload">unload()</a></h1>
	<h2>
  <p>void ofShader::unload()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This unload the shader, which means that it will not be active on the graphics card any longer.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- vars detail -->
              
              <!-- functions detail -->
            </div><!-- End Prose Block -->
          </div><!-- End Main Block -->
        </div>
      </div>
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Thursday, 17 January 2013 05:14:24 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

bb9a3174291cb0971a5d51babc9f9bc360090b5e
">

bb9a3174291cb0971a5d51babc9f9bc360090b5e
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





