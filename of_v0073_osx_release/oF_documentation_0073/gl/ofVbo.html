<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>    
  <title>openFrameworks</title>
<!-- syntax highlighting for the documentation -->
<link rel="stylesheet" type="text/css" href="../css/style.css?44443" media="all" />
  </head>
  <body>
    <div id="content">
      <a href="http://openframeworks.cc" target= "_blank"><img src="../images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofVbo</h1></div>
              <div id="editdocs">

              </div>
              
          </div>
          
          <div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">
              <p>
              
  <p>First things first: a Vertex Buffer Object (VBO) provides a way for you to create vertices, normals, colors, and texture coordinates on the graphics card for non-immediate mode rendering. This means that you can store it all on the graphics card and then access, update, or draw it, whenever you need. This is pretty convenient when you have something that you want to draw multiple times wihtout changing it much, because it means that, instead of needing to upload new data each time, you can simply draw it without needing to recreate all your vertices and colors, a philosophy which is probably familiar to you from working with the ofFbo or ofTexture.</p>
<p>There are a few things that are important to understand about VBOs:</p>
<p>Each property of the VBO - vertices, texCoords, normals, colors - can be either dynamic or static. You set it to static when you know that you won't be updating it later on. You set it to dynamic when you know you will be updating it later on.</p>
<p>Just like with ofMesh, you need to keep track of the vertices and their indices in order to make shapes and you can draw a VBO in any one of the OpenGL drawing modes, GL_LINE_STRIP, GL_POINTS, GL_QUADS, GL_TRIANGLES and GL_TRIANGLE_STRIP.</p>
<p>Vertices are passed to your graphics card and your graphics card fills in the spaces in between them in a process usually called the rendering pipeline. The rendering pipeline goes more or less like this:</p>
<ol>
<li>
<p>Say how youre going to connect all the points.</p>
</li>
<li>
<p>Make some points.</p>
</li>
<li>
<p>Say that youre done making points.</p>
</li>
</ol>
<p>You may be thinking: Ill just make eight vertices and voila: a cube. Not so quick. Theres a hitch and that hitch is that the OpenGL renderer has different ways of connecting the vertices that you pass to it and none are as efficient as to only need eight vertices to create a cube. Youve probably seen a version of the following image somewhere before.</p>
<p><img alt="gl vertices" src="gl_vertices_options.jpg" /></p>
<p>Generally, you have to create your points to fit the drawing mode that youve selected because of whats called winding. A vertex gets connected to another vertex in the order that the mode does its winding and this means that you might need multiple vertices in a given location to create the shape you want. The cube, for example, requires eighteen vertices, not the eight that you would expect. If you note the order of vertices in the GL chart above youll see that all of them use their vertices slightly differently (in particular you should make note of the GL_TRIANGLE_STRIP example). Drawing a shape requires that you keep track of which drawing mode is being used and which order your vertices are declared in. If youre thinking it would be nice if there were an abstraction layer for this, youre thinking right. Enter the mesh, which is really just an abstraction of the vertex and drawing mode that we started with but which has the added bonus of managing the draw order for you. That may seem insignificant at first, but it provides some real benefits when working with complex geometry.</p>
<p>The following example shows an ofVbo representing an icosahedron:</p>
<pre><code class="cpp">const ofIndexType Faces[] = {
    2, 1, 0,
    3, 2, 0,
    4, 3, 0,
    5, 4, 0,
    1, 5, 0,
    11, 6,  7,
    11, 7,  8,
    11, 8,  9,
    11, 9,  10,
    11, 10, 6,
    1, 2, 6,
    2, 3, 7,
    3, 4, 8,
    4, 5, 9,
    5, 1, 10,
    2,  7, 6,
    3,  8, 7,
    4,  9, 8,
    5, 10, 9,
    1, 6, 10 };
const float Verts[] = {
    0.000f,  0.000f,  1.000f,
    0.894f,  0.000f,  0.447f,
    0.276f,  0.851f,  0.447f,
    -0.724f,  0.526f,  0.447f,
    -0.724f, -0.526f,  0.447f,
    0.276f, -0.851f,  0.447f,
    0.724f,  0.526f, -0.447f,
    -0.276f,  0.851f, -0.447f,
    -0.894f,  0.000f, -0.447f,
    -0.276f, -0.851f, -0.447f,
    0.724f, -0.526f, -0.447f,
    0.000f,  0.000f, -1.000f };
ofVec3f v[12];
ofVec3f n[12];
ofFloatColor c[12];
ofVbo vbo;
void HelloWorldApp::setup()
{   
    int i, j = 0;
    for ( i = 0; i &lt; 12; i++ )
    {

        c[i].r = ofRandom(1.0);
        c[i].g = ofRandom(1.0);
        c[i].b = ofRandom(1.0);

        v[i][0] = Verts[j] * 100.f;
        j++;
        v[i][1] = Verts[j] * 100.f;
        j++;
        v[i][2] = Verts[j] * 100.f;
        j++;

    }

    vbo.setVertexData( &amp;v[0], 12, GL_STATIC_DRAW );
    vbo.setColorData( &amp;c[0], 12, GL_STATIC_DRAW );
    vbo.setIndexData( &amp;Faces[0], 60, GL_STATIC_DRAW );

    glEnable(GL_DEPTH_TEST);
}
void HelloWorldApp::draw(){
    ofTranslate(ofGetWidth()/2, ofGetHeight()/2, 100);
    ofRotate(ofGetElapsedTimef() * 20.0, 1, 1, 0);
    glPointSize(10.f);
    vbo.drawElements( GL_TRIANGLES, 60);
}
</code></pre>

<p><img alt="vbo result" src="vbo.png" /></p>
<p>You'll notice in a lot of the methods that a usage is required, for instance, setNormals(). The possible options are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY Each of these affects the speed of operations that you peform with the VBO and whether it's certain operations are allowed. For instance, if the vertices are STATIC, then they cannot be changed after they been loaded the first time, whereas if they're DYNAMIC, then they can be modified at any time later. The different modes can be broken down like so:</p>
<p>STREAM
The data store contents will be modified once and used at most a few times.</p>
<p>STATIC
The data store contents will be modified once and used many times.</p>
<p>DYNAMIC
The data store contents will be modified repeatedly and used many times.</p>
<p>The nature of access may be one of these:</p>
<p>DRAW
The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.</p>
<p>READ
The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.</p>
<p>COPY
The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.</p>

              </p>
        	</div><!-- End Prose Block -->
         </div><!-- End Main Block -->
	</div>
		<div class="page-wide">
      	<div id="top_list">
             
             <!-- list of methods -->
               
 			
			<p class="top_list_header"><a href="#methods">class methods</a></p>
			
                 <ul class="functionslist">
                     
                         
                              
                             <li> <a href="#bind">bind()</a> </li>
                         
                              
                             <li> <a href="#clear">clear()</a> </li>
                         
                              
                             <li> <a href="#clearColors">clearColors()</a> </li>
                         
                              
                             <li> <a href="#clearIndices">clearIndices()</a> </li>
                         
                              
                             <li> <a href="#clearNormals">clearNormals()</a> </li>
                         
                              
                             <li> <a href="#clearTexCoords">clearTexCoords()</a> </li>
                         
                              
                             <li> <a href="#clearVertices">clearVertices()</a> </li>
                         
                              
                             <li> <a href="#disableColors">disableColors()</a> </li>
                         
                              
                             <li> <a href="#disableIndices">disableIndices()</a> </li>
                         
                              
                             <li> <a href="#disableNormals">disableNormals()</a> </li>
                         
                              
                             <li> <a href="#disableTexCoords">disableTexCoords()</a> </li>
                         
                              
                             <li> <a href="#draw">draw(...)</a> </li>
                         
                              
                             <li> <a href="#drawElements">drawElements(...)</a> </li>
                         
                              
                             <li> <a href="#enableColors">enableColors()</a> </li>
                         
                              
                             <li> <a href="#enableIndices">enableIndices()</a> </li>
                         
                              
                             <li> <a href="#enableNormals">enableNormals()</a> </li>
                         
                              
                             <li> <a href="#enableTexCoords">enableTexCoords()</a> </li>
                         
                              
                             <li> <a href="#getColorId">getColorId()</a> </li>
                         
                              
                             <li> <a href="#getIndexId">getIndexId()</a> </li>
                         
                              
                             <li> <a href="#getIsAllocated">getIsAllocated()</a> </li>
                         
                              
                             <li> <a href="#getNormalId">getNormalId()</a> </li>
                         
                              
                             <li> <a href="#getTexCoordId">getTexCoordId()</a> </li>
                         
                              
                             <li> <a href="#getUsingColors">getUsingColors()</a> </li>
                         
                              
                             <li> <a href="#getUsingIndices">getUsingIndices()</a> </li>
                         
                              
                             <li> <a href="#getUsingNormals">getUsingNormals()</a> </li>
                         
                              
                             <li> <a href="#getUsingTexCoords">getUsingTexCoords()</a> </li>
                         
                              
                             <li> <a href="#getUsingVerts">getUsingVerts()</a> </li>
                         
                              
                             <li> <a href="#getVertId">getVertId()</a> </li>
                         
                              
                             <li> <a href="#operator=">operator=(...)</a> </li>
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#unbind">unbind()</a> </li>
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                 </ul>
            
             
             
             <!-- list of variables -->              
            
             
            
             <!-- list of functions -->              
            
		</div>

	</div>
		<div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">	
              
              <!-- methods detail -->
                  <h2><a name="methods"></a>ofVbo methods</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="bind">bind()</a></h1>
	<h2>
  <p>void ofVbo::bind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This is for advanced users who might want to use ways of drawing other than draw() or drawElements(), it simply binds all the arrays for the VBO.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clear">clear()</a></h1>
	<h2>
  <p>void ofVbo::clear()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This erases your VBO data from your graphics card, but not the VBO itself, so you can fill it with data again.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clearColors">clearColors()</a></h1>
	<h2>
  <p>void ofVbo::clearColors()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clearIndices">clearIndices()</a></h1>
	<h2>
  <p>void ofVbo::clearIndices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clearNormals">clearNormals()</a></h1>
	<h2>
  <p>void ofVbo::clearNormals()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clearTexCoords">clearTexCoords()</a></h1>
	<h2>
  <p>void ofVbo::clearTexCoords()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="clearVertices">clearVertices()</a></h1>
	<h2>
  <p>void ofVbo::clearVertices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="disableColors">disableColors()</a></h1>
	<h2>
  <p>void ofVbo::disableColors()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="disableIndices">disableIndices()</a></h1>
	<h2>
  <p>void ofVbo::disableIndices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="disableNormals">disableNormals()</a></h1>
	<h2>
  <p>void ofVbo::disableNormals()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="disableTexCoords">disableTexCoords()</a></h1>
	<h2>
  <p>void ofVbo::disableTexCoords()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofVbo::draw(int drawMode, int first, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This method allows you to draw your VBO but unlike drawElements() ignores any indices that you might have set up. This is an important distinction between the two methods.
mode
Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
first
Specifies the starting index in the enabled arrays.
total
Specifies the number of indices to be rendered. This last part is pretty important: if you have more indices than vertices you'll want to make sure that you pass the number of indices, not the number of vertices.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="drawElements">drawElements(...)</a></h1>
	<h2>
  <p>void ofVbo::drawElements(int drawMode, int amt)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>drawElements allows you use indices, unlike draw() which ignores them.
drawMode
Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.</p>
<pre><code class="cpp">vbo.drawElements( GL_TRIANGLES, 60);
</code></pre>

<p>amt specifies the number of indices to be rendered. This last part is pretty important: if you have more indices than vertices you'll want to make sure that you pass the number of indices, not the number of vertices.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="enableColors">enableColors()</a></h1>
	<h2>
  <p>void ofVbo::enableColors()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="enableIndices">enableIndices()</a></h1>
	<h2>
  <p>void ofVbo::enableIndices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="enableNormals">enableNormals()</a></h1>
	<h2>
  <p>void ofVbo::enableNormals()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="enableTexCoords">enableTexCoords()</a></h1>
	<h2>
  <p>void ofVbo::enableTexCoords()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getColorId">getColorId()</a></h1>
	<h2>
  <p>GLuint ofVbo::getColorId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getIndexId">getIndexId()</a></h1>
	<h2>
  <p>GLuint ofVbo::getIndexId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getIsAllocated">getIsAllocated()</a></h1>
	<h2>
  <p>bool ofVbo::getIsAllocated()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the ofVbo has been allocated or not. This is important to check before you start drawing or manipulating the vbo.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getNormalId">getNormalId()</a></h1>
	<h2>
  <p>GLuint ofVbo::getNormalId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getTexCoordId">getTexCoordId()</a></h1>
	<h2>
  <p>GLuint ofVbo::getTexCoordId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getUsingColors">getUsingColors()</a></h1>
	<h2>
  <p>bool ofVbo::getUsingColors()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the vertices within the VBO have colors associated with them or not.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getUsingIndices">getUsingIndices()</a></h1>
	<h2>
  <p>bool ofVbo::getUsingIndices()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the VBO has assigned indices or not.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getUsingNormals">getUsingNormals()</a></h1>
	<h2>
  <p>bool ofVbo::getUsingNormals()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the surfaces of the VBO have normals associated with them or not.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getUsingTexCoords">getUsingTexCoords()</a></h1>
	<h2>
  <p>bool ofVbo::getUsingTexCoords()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the vertices of the VBO have texture coordinates associated with them or not.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getUsingVerts">getUsingVerts()</a></h1>
	<h2>
  <p>bool ofVbo::getUsingVerts()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns whether the ofVbo is using vertices or not. A VBO can exist without vertices, though it's quite unusual.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getVertId">getVertId()</a></h1>
	<h2>
  <p>GLuint ofVbo::getVertId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator=">operator=(...)</a></h1>
	<h2>
  <p>ofVbo ofVbo::operator=(const ofVbo &amp;mom)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This is the equals operator, so that you can do the following:</p>
<pre><code class="cpp">ofVbo v1;
// filll v1;
ofVbo v2 = v1; // v2 now contains all of v1s properties in a separate VBO
</code></pre>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setColorData">setColorData(...)</a></h1>
	<h2>
  <p>void ofVbo::setColorData(const ofFloatColor *colors, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to set the colors for a vertex using an array of ofFloatColor instances.</p>
<pre><code class="cpp">ofFloatColor c[12];
// fill in the colors and vertices
vbo.setColorData( &amp;c[0], 12, GL_STATIC_DRAW );
</code></pre>

<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setColorData">setColorData(...)</a></h1>
	<h2>
  <p>void ofVbo::setColorData(const float *color0r, int total, int usage, int stride=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the color data for the ofVbo from a pointer to an array of floats. The colors are RGB and are floats from 0.f - 1.f</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setIndexData">setIndexData(...)</a></h1>
	<h2>
  <p>void ofVbo::setIndexData(const ofIndexType *indices, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the index data for the VBO from a pointer to an array of ints. Each int represents the index of a vertex, and when the vbo is drawn the indices are used to generate the geometry from the indices.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setMesh">setMesh(...)</a></h1>
	<h2>
  <p>void ofVbo::setMesh(const ofMesh &amp;mesh, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to pass a mesh to the ofVbo and populate the vertices, texture coordinates, and other properties of the VBO from the ofMesh instance. You can think of this as essentially moving geometry data from the CPU to the GPU.</p>
<pre><code class="cpp">ofxAssimpModelLoader model;
model.loadModel(&quot;astroBoy_walk.dae&quot;,true);
ofMesh mesh = model.getMesh(0);
ofVbo vbo;
vbo.setMesh(mesh, GL_STATIC_DRAW);
</code></pre>

<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setNormalData">setNormalData(...)</a></h1>
	<h2>
  <p>void ofVbo::setNormalData(const ofVec3f *normals, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the normal data for the VBO from a pointer to an array of ofVec3f instances. The normals are calculated as the vector perpendicular to a face. The mathematical definition of a normal is shown on the left, while the way that a normal is calculated for a triangle is shown on the right.</p>
<p><img alt="vbo normals" src="vboNormals.png" /></p>
<p>One technique for calculating normals is something like the following:</p>
<pre><code class="cpp">int* indices;
ofVec3f* verts;
ofVec3f* normals;
// allocate and create normals, indices, and verts
for ( int i = 0, int j = 0; i &lt; NUM_INDICES; i+=3, j++) {
    ofVec3f v[3] = { vertices[i], verts[(i+1)], verts[(i+2)] };
    ofVec3f temp1 = v[1] - v[0];
    ofVec3f temp2 = v[2] - v[0];
    ofVec3f norm = temp1.getCrossed(temp2);

      for (int j = 0; j &lt; 3; ++j) {
        Vector3 a = v[(i+1) % 3] - v[j];
        Vector3 b = v[(j+2) % 3] - v[j];
        float weight = acos(a.dot(b) / (a.length() * b.length()));
        norm += weight * normal;
    }

    normals[j] = norm;
}
</code></pre>

<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setNormalData">setNormalData(...)</a></h1>
	<h2>
  <p>void ofVbo::setNormalData(const float *normal0x, int total, int usage, int stride=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the normals data for the ofVbo from a pointer to an array of floats, x,y,z, for each face, so a 3D cube would require an array of 18 floats, 3 for each face.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setTexCoordData">setTexCoordData(...)</a></h1>
	<h2>
  <p>void ofVbo::setTexCoordData(const ofVec2f *texCoords, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the texture coordinate data for the VBO from a pointer to an array of ofVec2f instances. Each ofVec2f represents the texture coordinate of a vertex. By default OF uses ARB coords, so you can use pixel coordinates rather than normalized UV coordinates.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setTexCoordData">setTexCoordData(...)</a></h1>
	<h2>
  <p>void ofVbo::setTexCoordData(const float *texCoord0x, int total, int usage, int stride=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the texCoord data for the ofVbo from a pointer to an array of floats, ST, for each face, so a 3D cube would require an array of 16 floats, 2 for each vertex.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setVertexData">setVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::setVertexData(const ofVec3f *verts, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the vertex data for the ofVbo from a pointer to an array of ofVec3f instances. This creates a 3D vbo.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setVertexData">setVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::setVertexData(const ofVec2f *verts, int total, int usage)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the vertex data for the ofVbo from a pointer to an array of ofVec2f instances. This creates a 2D vbo.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setVertexData">setVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::setVertexData(const float *vert0x, int numCoords, int total, int usage, int stride=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This sets the vertex data for the ofVbo from a pointer to an array of floats. The numCoords determines whether you're creating a 3D or 2D vbo, i.e. a 3D cube would require an array of 24 floats, and numCoords to be 8.</p>
<p>The possible options for usage are: GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="unbind">unbind()</a></h1>
	<h2>
  <p>void ofVbo::unbind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This is for advanced users who might want to use ways of drawing other than draw() or drawElements(), it simply unbinds all the arrays for the VBO.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateColorData">updateColorData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateColorData(const ofFloatColor *colors, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the color data for each vertex of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the vertex colors at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateColorData">updateColorData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateColorData(const float *color0r, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the vertex colors of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the colors at any time using an array of floats.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateIndexData">updateIndexData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateIndexData(const ofIndexType *indices, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the indices of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the indices at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateMesh">updateMesh(...)</a></h1>
	<h2>
  <p>void ofVbo::updateMesh(const ofMesh &amp;mesh)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Updates all the data within the VBO from the data in the ofMesh.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateNormalData">updateNormalData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateNormalData(const ofVec3f *normals, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the normals of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the normals at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateNormalData">updateNormalData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateNormalData(const float *normal0x, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the normals of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the normal data at any time using an array of floats.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateTexCoordData">updateTexCoordData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateTexCoordData(const ofVec2f *texCoords, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the texture coordinates of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the texcoords at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateTexCoordData">updateTexCoordData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateTexCoordData(const float *texCoord0x, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the texture coords of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the tex coords at any time using an array of floats.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateVertexData">updateVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateVertexData(const ofVec3f *verts, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the vertices of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the vertices at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateVertexData">updateVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateVertexData(const ofVec2f *verts, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the vertices of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the vertices at any time.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="updateVertexData">updateVertexData(...)</a></h1>
	<h2>
  <p>void ofVbo::updateVertexData(const float *ver0x, int total)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If the vertices of the VBO have been declared as GL_DYNAMIC_DRAW, then you can update the indices at any time using an array of floats.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- vars detail -->
              
              <!-- functions detail -->
            </div><!-- End Prose Block -->
          </div><!-- End Main Block -->
        </div>
      </div>
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Thursday, 17 January 2013 05:14:25 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

bb9a3174291cb0971a5d51babc9f9bc360090b5e
">

bb9a3174291cb0971a5d51babc9f9bc360090b5e
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





