<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>    
  <title>openFrameworks</title>
<!-- syntax highlighting for the documentation -->
<link rel="stylesheet" type="text/css" href="../css/style.css?44443" media="all" />
  </head>
  <body>
    <div id="content">
      <a href="http://openframeworks.cc" target= "_blank"><img src="../images/ofw-logo.png" border="0" alt="openFrameworks" /></a>
      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofFbo</h1></div>
              <div id="editdocs">

              </div>
              
          </div>
          
          <div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">
              <p>
              
  <p>As an example, with an fbo you can do some drawing to the fbo (instead of to the screen or a texture) and then do some blurring, maybe invert the colors, combine multiple images, all without needing to draw it to the screen until you're ready.
fbos are also used to create views of other scenes, like a TV in a house. A scene can be rendered through an FBO to a texture, then that texture can be applied to the surface of another object.
You can also create a depth buffer within your fbo to figure out which objects should go in front of which other objects.
As an example of an advanced usage:
Create an ofFbo.
Attach the color buffer of the ofFbo to a texture.
Attach the depth buffer of the ofFbo to a texture.
Render the texture to screen with a pixel shader using ofShader.
Rad!
The following code snippet shows ping-ponging, a common technique with FBOs that involves adding two textures to the FBO and blurring one then the other in succession to create a blur effect.</p>
<pre><code class="cpp">// draw scene into fbo
fbo.begin();
vidGrabber.draw(0, 0, fbo.getWidth(), fbo.getHeight());
fbo.end();
// ping pong between two attachments using shader
fbo.begin();
shader.begin();
// the fbo contains two textures, so we blur one
// then copy it to the other and repeat 8 times
for(int i=0; i&lt;8; i++) {
    int srcPos = i % 2;             // attachment to write to
    int dstPos = 1 - srcPos;        // attachment to read from
    glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT + dstPos);    // write to this texture
    ofClear(0, 0, 0, 0);

    shader.setUniform1i(&quot;tex0&quot;, 0);
    shader.setUniform1f(&quot;sampleOffset&quot;, i*2+1);
    fbo.getTextureReference(srcPos).draw(0, 0);
}
shader.end();
fbo.end();
fbo.draw(0, 0);
</code></pre>

<p>Bloom effects are also often done with FBO objects as as Multiple Render to Texture or MRT effectrs.</p>

              </p>
        	</div><!-- End Prose Block -->
         </div><!-- End Main Block -->
	</div>
		<div class="page-wide">
      	<div id="top_list">
             
             <!-- list of methods -->
               
 			
			<p class="top_list_header"><a href="#methods">class methods</a></p>
			
                 <ul class="functionslist">
                     
                              
                             <li> <a href="#activateAllDrawBuffers">activateAllDrawBuffers()</a> </li>
                         
                              
                             <li> <a href="#allocate">allocate(...)</a> </li>
                         
                         
                              
                             <li> <a href="#begin">begin()</a> </li>
                         
                         
                              
                             <li> <a href="#bind">bind()</a> </li>
                         
                              
                             <li> <a href="#checkGLSupport">checkGLSupport()</a> </li>
                         
                         
                         
                         
                         
                         
                              
                             <li> <a href="#draw">draw(...)</a> </li>
                         
                         
                              
                             <li> <a href="#end">end()</a> </li>
                         
                              
                             <li> <a href="#getDefaultTextureIndex">getDefaultTextureIndex()</a> </li>
                         
                              
                             <li> <a href="#getDepthBuffer">getDepthBuffer()</a> </li>
                         
                              
                             <li> <a href="#getDepthTexture">getDepthTexture()</a> </li>
                         
                              
                             <li> <a href="#getFbo">getFbo()</a> </li>
                         
                              
                             <li> <a href="#getHeight">getHeight()</a> </li>
                         
                              
                             <li> <a href="#getNumTextures">getNumTextures()</a> </li>
                         
                              
                             <li> <a href="#getStencilBuffer">getStencilBuffer()</a> </li>
                         
                              
                             <li> <a href="#getTextureReference">getTextureReference()</a> </li>
                         
                         
                              
                             <li> <a href="#getWidth">getWidth()</a> </li>
                         
                              
                             <li> <a href="#isAllocated">isAllocated()</a> </li>
                         
                              
                             <li> <a href="#maxColorAttachments">maxColorAttachments()</a> </li>
                         
                              
                             <li> <a href="#maxDrawBuffers">maxDrawBuffers()</a> </li>
                         
                              
                             <li> <a href="#maxSamples">maxSamples()</a> </li>
                         
                              
                             <li> <a href="#operator=">operator=(...)</a> </li>
                         
                              
                             <li> <a href="#readToPixels">readToPixels(...)</a> </li>
                         
                         
                         
                              
                             <li> <a href="#resetAnchor">resetAnchor()</a> </li>
                         
                              
                             <li> <a href="#setActiveDrawBuffer">setActiveDrawBuffer(...)</a> </li>
                         
                              
                             <li> <a href="#setActiveDrawBuffers">setActiveDrawBuffers(...)</a> </li>
                         
                              
                             <li> <a href="#setAnchorPercent">setAnchorPercent(...)</a> </li>
                         
                              
                             <li> <a href="#setAnchorPoint">setAnchorPoint(...)</a> </li>
                         
                              
                             <li> <a href="#setDefaultTextureIndex">setDefaultTextureIndex(...)</a> </li>
                         
                              
                             <li> <a href="#setUseTexture">setUseTexture(...)</a> </li>
                         
                              
                             <li> <a href="#unbind">unbind()</a> </li>
                         
                         
                 </ul>
            
             
             
             <!-- list of variables -->              
            
             
            
             <!-- list of functions -->              
            
		</div>

	</div>
		<div class="page-left-wide">
          <div id="main_block">
            <div id="prose_block">	
              
              <!-- methods detail -->
                  <h2><a name="methods"></a>ofFbo methods</h2>
                            
<div class="documentation_detail">
  	 
	<h1><a name="activateAllDrawBuffers">activateAllDrawBuffers()</a></h1>
	<h2>
  <p>void ofFbo::activateAllDrawBuffers()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="allocate">allocate(...)</a></h1>
	<h2>
  <p>void ofFbo::allocate(int width, int height, int internalformat=GL_RGBA, int numSamples=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Before you use the fbo you need to allocate it. This sets the width, height, and GL type of the fbo (i.e. whether it has alpha data or not) and the number of samples for MSAA. MSAA is sort of a big topic.
MSAA is what you typically have in hardware on a modern graphics card. The graphics card renders to a surface that is larger than the final image, but in shading each "cluster" of samples (that will end up in a single pixel on the final screen) the pixel shader is run only once. We save a ton of fill rate, but we still burn memory bandwidth.
This technique does not anti-alias any effects coming out of the shader, because the shader runs at 1x, so alpha cutouts are jagged. This is the most common way to run a forward-rendering game. MSAA does not work for a deferred renderer because lighting decisions are made after the MSAA is "resolved" (down-sized) to its final image size.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="allocate">allocate(...)</a></h1>
	<h2>
  <p>void ofFbo::allocate(Settings settings=Settings())</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>You can also allocate the ofFbo using a Settings object</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="begin">begin()</a></h1>
	<h2>
  <p>void ofFbo::begin()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Any drawing that you do after begin() is drawn into the fbo rather than the screen. This is how you draw things into your ofFbo instance.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="begin">begin(...)</a></h1>
	<h2>
  <p>void ofFbo::begin(bool setupScreen=true)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="bind">bind()</a></h1>
	<h2>
  <p>void ofFbo::bind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This lets you draw the fbo using vertices to define the area that the fbo will be drawn into. This can be an ofRectangle, ofMesh, or other vertex based drawing technique.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="checkGLSupport">checkGLSupport()</a></h1>
	<h2>
  <p>bool ofFbo::checkGLSupport()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you quickly check whether your graphics card supports FBO objects.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofFbo::draw(float x, float y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you draw everything that's in your fbo to the screen using its default height and width at the x, y indicated.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="draw">draw(...)</a></h1>
	<h2>
  <p>void ofFbo::draw(float x, float y, float width, float height)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you draw everything that's in your fbo to the screen using any height and width. Any stretching is up to you to handle appropriately.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="end">end()</a></h1>
	<h2>
  <p>void ofFbo::end()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Any drawing that you do after end() is drawn into the fbo rather than the screen. This is how you stop drawing things into your ofFbo instance.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getDefaultTextureIndex">getDefaultTextureIndex()</a></h1>
	<h2>
  <p>int ofFbo::getDefaultTextureIndex()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>If you've set the default texture reference, you can get access to it here.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getDepthBuffer">getDepthBuffer()</a></h1>
	<h2>
  <p>GLuint ofFbo::getDepthBuffer()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This gives you the OpenGL id of the depthBuffer that the fbo contains.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getDepthTexture">getDepthTexture()</a></h1>
	<h2>
  <p>ofTexture ofFbo::getDepthTexture()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getFbo">getFbo()</a></h1>
	<h2>
  <p>GLuint ofFbo::getFbo()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returnes the GLuint of Fbo for advanced actions, if you're interested in doing something with the FBO id directly.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getHeight">getHeight()</a></h1>
	<h2>
  <p>float ofFbo::getHeight()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the height of the fbo. This is just like height of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getNumTextures">getNumTextures()</a></h1>
	<h2>
  <p>int ofFbo::getNumTextures()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the number of textures that the fbo contains.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getStencilBuffer">getStencilBuffer()</a></h1>
	<h2>
  <p>GLuint ofFbo::getStencilBuffer()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This gives you the OpenGL id of the depthBuffer that the fbo contains.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getTextureReference">getTextureReference()</a></h1>
	<h2>
  <p>ofTexture ofFbo::getTextureReference()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This gives you access to the ofTexture contained w/in the fbo. This returns the texture index returned by setDefaultTextureIndex() if you've set it there.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getTextureReference">getTextureReference(...)</a></h1>
	<h2>
  <p>ofTexture ofFbo::getTextureReference(int attachmentPoint)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This gives you access to a particular ofTexture if there are more than 1 contained w/in the fbo.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="getWidth">getWidth()</a></h1>
	<h2>
  <p>float ofFbo::getWidth()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returns the width of the fbo that was set when it was allocated. This is just like width of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="isAllocated">isAllocated()</a></h1>
	<h2>
  <p>bool ofFbo::isAllocated()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="maxColorAttachments">maxColorAttachments()</a></h1>
	<h2>
  <p>int ofFbo::maxColorAttachments()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returnes the max number of simultaneous max color attachments, i.e. textures that will just be used for color information.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="maxDrawBuffers">maxDrawBuffers()</a></h1>
	<h2>
  <p>int ofFbo::maxDrawBuffers()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This returnes the max number of simultaneous draw buffers that your graphics card supports, i.e. color buffers that can be drawn to simultaneously. This is usually 4 at present.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="maxSamples">maxSamples()</a></h1>
	<h2>
  <p>int ofFbo::maxSamples()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This is the maximum number of MSAA samples that your graphic card supports.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="operator=">operator=(...)</a></h1>
	<h2>
  <p>ofFbo ofFbo::operator=(const ofFbo &amp;fbo)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This overloaded operator allows you to set one fbo from another using the = operator. Very convenient.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="readToPixels">readToPixels(...)</a></h1>
	<h2>
  <p>void ofFbo::readToPixels(ofPixels &amp;pixels, int attachmentPoint=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to get the pixels from an ofFbo and store it in an ofPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="readToPixels">readToPixels(...)</a></h1>
	<h2>
  <p>void ofFbo::readToPixels(ofShortPixels &amp;pixels, int attachmentPoint=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to get the pixels from an ofFbo and store it in an ofShortPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image at short ints, or non-floating point values.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="readToPixels">readToPixels(...)</a></h1>
	<h2>
  <p>void ofFbo::readToPixels(ofFloatPixels &amp;pixels, int attachmentPoint=0)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you to get the pixels from an ofFbo and store it in an ofShortPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image as floating point values.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="resetAnchor">resetAnchor()</a></h1>
	<h2>
  <p>void ofFbo::resetAnchor()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you reset the anchor position.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setActiveDrawBuffer">setActiveDrawBuffer(...)</a></h1>
	<h2>
  <p>void ofFbo::setActiveDrawBuffer(int i)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setActiveDrawBuffers">setActiveDrawBuffers(...)</a></h1>
	<h2>
  <p>void ofFbo::setActiveDrawBuffers(const vector&lt; int &gt; &amp;i)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAnchorPercent">setAnchorPercent(...)</a></h1>
	<h2>
  <p>void ofFbo::setAnchorPercent(float xPct, float yPct)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>You can set the anchor position that the texture will be drawn at. This means that passing 50, 50 will draw the ofFbo center at the point you pass in to the draw() method.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setAnchorPoint">setAnchorPoint(...)</a></h1>
	<h2>
  <p>void ofFbo::setAnchorPoint(float x, float y)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you set the anchor position of the texture in the fbo when you draw it.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setDefaultTextureIndex">setDefaultTextureIndex(...)</a></h1>
	<h2>
  <p>void ofFbo::setDefaultTextureIndex(int defaultTexture)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This allows you set the default texture that your fbo will use. If you're using multiple textures, this will return the one that should be draw to, scaled, and positioned.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="setUseTexture">setUseTexture(...)</a></h1>
	<h2>
  <p>void ofFbo::setUseTexture(bool bUseTex)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>This method does nothing.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
                            
<div class="documentation_detail">
  	 
	<h1><a name="unbind">unbind()</a></h1>
	<h2>
  <p>void ofFbo::unbind()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>After you bind the fbo and draw with it, call fbo to stop the fbo from being attached to vertices that are created.</p>

	</div>
	<div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div>
</div>


    
              
              <!-- vars detail -->
              
              <!-- functions detail -->
            </div><!-- End Prose Block -->
          </div><!-- End Main Block -->
        </div>
      </div>
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Thursday, 17 January 2013 05:14:24 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

bb9a3174291cb0971a5d51babc9f9bc360090b5e
">

bb9a3174291cb0971a5d51babc9f9bc360090b5e
</a>

<!--br/>RSS feeds for <a href="/blog/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>








      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





